/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    module2.exports = {
      "version": "0.24.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    module2.exports = require_axios();
  }
});

// main.ts
__export(exports, {
  default: () => AIPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/AIPluginView.ts
var import_obsidian = __toModule(require("obsidian"));
var AI_PLUGIN_VIEW_TYPE = "ai-plugin-view";
var AIPluginView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.appendTarget = "current";
    this.selectedInboxPath = "";
    this.loading = false;
    this.error = null;
    this.lastUpdate = Date.now();
    this.selectedNote = null;
    this.isIndexing = false;
    this.plugin = plugin;
    this.activeTab = "organize";
  }
  getViewType() {
    return AI_PLUGIN_VIEW_TYPE;
  }
  getDisplayText() {
    return "AI Assistant";
  }
  getIcon() {
    return "brain";
  }
  async onOpen() {
    await this.initializeView();
    await this.startInitialIndexing();
    this.plugin.aiChat.addMessageListener(this.updateChatMessages.bind(this));
  }
  async onClose() {
    this.containerEl.empty();
    this.plugin.aiChat.removeMessageListener(this.updateChatMessages.bind(this));
  }
  createNoteSelector(container) {
    const selectorContainer = container.createDiv("ai-plugin-note-selector-container");
    const activeNote = this.app.workspace.getActiveFile();
    const noteName = activeNote ? activeNote.basename : "Select a note";
    const selectorButton = selectorContainer.createEl("button", {
      cls: "ai-plugin-button ai-plugin-note-button",
      text: noteName
    });
    const icon = selectorButton.createSpan("ai-plugin-button-icon");
    icon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-file-text"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>`;
    selectorButton.addEventListener("click", (event) => {
      const menu = new import_obsidian.Menu();
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        menu.addItem((item) => {
          item.setTitle(activeFile.basename).setIcon("file-text").onClick(() => this.selectNote(activeFile));
        });
      }
      const recentFiles = this.app.workspace.getLastOpenFiles().slice(0, 5).map((path) => this.app.vault.getAbstractFileByPath(path)).filter((file) => file instanceof import_obsidian.TFile);
      if (recentFiles.length > 0) {
        menu.addSeparator();
        recentFiles.forEach((file) => {
          menu.addItem((item) => {
            item.setTitle(file.basename).setIcon("clock").onClick(() => this.selectNote(file));
          });
        });
      }
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Browse all notes...").setIcon("search").onClick(() => this.showFileBrowser());
      });
      menu.showAtMouseEvent(event);
    });
  }
  async selectNote(file) {
    this.selectedNote = file;
    const leaf = this.app.workspace.getLeaf();
    await leaf.openFile(file);
    this.updateNoteSelector();
    await this.ensureNoteIndexed(file);
  }
  updateNoteSelector() {
    const selectorButton = this.containerEl.querySelector(".ai-plugin-note-button");
    if (selectorButton && this.selectedNote) {
      selectorButton.textContent = this.selectedNote.basename;
    }
  }
  async showFileBrowser() {
    const modal = new FileBrowserModal(this.app, (file) => this.selectNote(file));
    modal.open();
  }
  async startInitialIndexing() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      await this.ensureNoteIndexed(activeFile);
    }
  }
  async ensureNoteIndexed(file) {
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    this.updateIndexingStatus("Indexing...");
    try {
      await this.plugin.embeddingManager.getEmbeddingsForFile(file);
      this.updateIndexingStatus("Indexed");
    } catch (error) {
      this.updateIndexingStatus("Indexing failed");
      new import_obsidian.Notice("Failed to index note: " + error.message);
    } finally {
      this.isIndexing = false;
    }
  }
  updateIndexingStatus(status) {
    if (this.indexingStatus) {
      this.indexingStatus.empty();
      const icon = this.indexingStatus.createSpan("ai-plugin-status-icon");
      icon.innerHTML = this.isIndexing ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-loader"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>` : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-check-circle"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`;
      const text = this.indexingStatus.createSpan("ai-plugin-status-text");
      text.textContent = status;
    }
  }
  async initializeView() {
    const container = this.containerEl.createDiv("ai-plugin-container");
    this.indexingStatus = container.createDiv("ai-plugin-status-bar");
    this.updateIndexingStatus("Ready");
    const noteSelector = container.createDiv("ai-plugin-note-selector");
    this.createNoteSelector(noteSelector);
    const navContainer = container.createDiv("ai-plugin-nav");
    this.createNavigationTabs(navContainer);
    const contentContainer = container.createDiv("ai-plugin-content");
    await this.drawActiveTab(contentContainer);
    this.registerDomEvents();
  }
  createNavigationTabs(navContainer) {
    const tabs = [
      { id: "organize", icon: "folder", label: "Organize" },
      { id: "analyze", icon: "search", label: "Analyze" },
      { id: "enhance", icon: "edit", label: "Enhance" },
      { id: "chat", icon: "message-circle", label: "Chat" },
      { id: "inbox", icon: "inbox", label: "Inbox" }
    ];
    tabs.forEach((tab) => {
      const tabEl = navContainer.createDiv(`ai-plugin-tab ${this.activeTab === tab.id ? "active" : ""}`);
      tabEl.setAttribute("data-tab", tab.id);
      const icon = tabEl.createSpan("ai-plugin-tab-icon");
      icon.addClass(tab.icon);
      tabEl.createSpan("ai-plugin-tab-label", (el) => {
        el.textContent = tab.label;
      });
      tabEl.addEventListener("click", () => this.switchTab(tab.id));
    });
  }
  async switchTab(tabId) {
    this.activeTab = tabId;
    this.containerEl.findAll(".ai-plugin-tab").forEach((tab) => {
      tab.classList.toggle("active", tab.getAttribute("data-tab") === tabId);
    });
    const contentContainer = this.containerEl.querySelector(".ai-plugin-content");
    if (contentContainer) {
      await this.drawActiveTab(contentContainer);
    }
  }
  registerDomEvents() {
    this.registerEvent(this.app.workspace.on("file-open", () => {
      this.updateViewForCurrentFile();
    }));
    this.registerEvent(this.app.vault.on("modify", () => {
      this.updateViewForCurrentFile();
    }));
  }
  async updateViewForCurrentFile() {
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    if (this.activeTab === "analyze" || this.activeTab === "enhance") {
      const contentContainer = this.containerEl.querySelector(".ai-plugin-content");
      if (contentContainer) {
        await this.drawActiveTab(contentContainer);
      }
    }
  }
  setLoading(loading) {
    this.loading = loading;
    const container = this.containerEl.querySelector(".ai-plugin-content");
    if (container) {
      container.toggleClass("loading", loading);
    }
  }
  setError(error) {
    this.error = error;
    if (error) {
      new import_obsidian.Notice(error);
    }
  }
  async saveState() {
    await this.plugin.saveData({
      activeTab: this.activeTab,
      selectedInboxPath: this.selectedInboxPath,
      appendTarget: this.appendTarget,
      lastUpdate: this.lastUpdate
    });
  }
  async loadState() {
    const data = await this.plugin.loadData();
    if (data) {
      this.activeTab = data.activeTab || "organize";
      this.selectedInboxPath = data.selectedInboxPath || "";
      this.appendTarget = data.appendTarget || "current";
      this.lastUpdate = data.lastUpdate || Date.now();
    }
  }
  async drawActiveTab(container) {
    container.empty();
    switch (this.activeTab) {
      case "organize":
        this.drawOrganizeTab(container);
        break;
      case "analyze":
        this.drawAnalyzeTab(container);
        break;
      case "enhance":
        this.drawEnhanceTab(container);
        break;
      case "chat":
        this.drawChatTab(container);
        break;
      case "inbox":
        this.drawInboxTab(container);
        break;
    }
  }
  createActionButton(container, text, icon, onClick) {
    const button = container.createEl("button", {
      cls: "ai-plugin-button",
      text
    });
    if (icon) {
      button.prepend(this.createIcon(icon));
    }
    button.addEventListener("click", onClick);
  }
  createIcon(name) {
    const icon = document.createElement("span");
    icon.classList.add("icon", name);
    return icon;
  }
  async getActiveFileContent() {
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active file");
      return null;
    }
    const content = await this.app.vault.read(file);
    return { file, content };
  }
  drawOrganizeTab(container) {
    const section = container.createDiv("ai-plugin-section");
    section.createEl("h3", { text: "Organize Notes" });
    const actionsDiv = section.createDiv("ai-plugin-actions");
    this.createActionButton(actionsDiv, "Suggest Location", "folder-plus", async () => {
      const fileData = await this.getActiveFileContent();
      if (!fileData)
        return;
      const suggestedPath = await this.plugin.notePathManager.getSuggestedPath(fileData.file);
      if (suggestedPath) {
        new PreviewModal(this.app, {
          original: fileData.file.path,
          modified: suggestedPath,
          type: "path"
        }, async (accepted) => {
          if (accepted) {
            await this.plugin.notePathManager.moveNote(fileData.file, suggestedPath);
            new import_obsidian.Notice("File moved successfully");
          }
        }).open();
      } else {
        new import_obsidian.Notice("No location suggestion available");
      }
    });
    this.createActionButton(actionsDiv, "Atomize Note", "scissors", async () => {
      const fileData = await this.getActiveFileContent();
      if (!fileData)
        return;
      try {
        const atomicNotes = await this.plugin.atomizer.atomizeNote(fileData.file);
        new AtomicNotesPreviewModal(this.app, atomicNotes, async (accepted) => {
          if (accepted) {
            for (const note of atomicNotes) {
              await this.app.vault.create(`${note.title}.md`, note.content);
            }
            new import_obsidian.Notice(`Created ${atomicNotes.length} atomic notes`);
          }
        }).open();
      } catch (error) {
        new import_obsidian.Notice(`Error atomizing note: ${error.message}`);
      }
    });
  }
  drawAnalyzeTab(container) {
    const section = container.createDiv("ai-plugin-section");
    section.createEl("h3", { text: "Analyze Content" });
    const actionsDiv = section.createDiv("ai-plugin-actions");
    this.createActionButton(actionsDiv, "Find Similar Notes", "search", async () => {
      const fileData = await this.getActiveFileContent();
      if (!fileData)
        return;
      const results = await this.plugin.vaultQuerier.queryVault(fileData.content, {
        limit: 5,
        includeContent: true
      });
      new SimilarNotesModal(this.app, results).open();
    });
    this.createActionButton(actionsDiv, "Extract Key Concepts", "book-open", async () => {
      const fileData = await this.getActiveFileContent();
      if (!fileData)
        return;
      const concepts = await this.plugin.nlpManager.performTask({
        type: "keywords",
        options: { minScore: 0.5 }
      }, fileData.content);
      new ConceptsModal(this.app, concepts.result).open();
    });
  }
  drawChatTab(container) {
    const section = container.createDiv("ai-plugin-section");
    const headerEl = section.createDiv("ai-plugin-chat-header");
    headerEl.createEl("h3", { text: "AI Chat" });
    const modelInfo = headerEl.createDiv("ai-plugin-model-info");
    modelInfo.setText(`Using model: ${this.plugin.modelManager.getCurrentModel()}`);
    const appendOptions = section.createDiv("ai-plugin-append-options");
    const appendSelect = appendOptions.createEl("select", { cls: "ai-plugin-select" });
    appendSelect.createEl("option", { text: "Append to current note", value: "current" });
    appendSelect.createEl("option", { text: "Append to specific note", value: "specific" });
    appendSelect.value = this.appendTarget;
    appendSelect.addEventListener("change", () => {
      this.appendTarget = appendSelect.value;
      if (this.appendTarget === "specific") {
        new import_obsidian.Notice("Note selection will be implemented soon");
      }
    });
    this.chatEl = section.createDiv("ai-plugin-chat-messages");
    this.updateChatMessages(this.plugin.aiChat.getMessages());
    const inputContainer = section.createDiv("ai-plugin-chat-input-container");
    this.inputEl = inputContainer.createEl("textarea", {
      cls: "ai-plugin-chat-input",
      attr: {
        placeholder: "Type your message...",
        rows: "3"
      }
    });
    const sendButton = inputContainer.createEl("button", {
      text: "Send",
      cls: "ai-plugin-chat-send"
    });
    sendButton.addEventListener("click", () => this.handleSendMessage());
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSendMessage();
      }
    });
  }
  async handleSendMessage() {
    const content = this.inputEl.value.trim();
    if (!content)
      return;
    this.inputEl.value = "";
    const typingEl = this.addTypingIndicator();
    try {
      const response = await this.plugin.aiChat.sendMessage(content);
      typingEl.remove();
      if (this.appendTarget === "current") {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          await this.plugin.aiChat.appendToNote(response, activeFile);
          new import_obsidian.Notice("Response appended to current note");
        }
      }
    } catch (error) {
      typingEl.remove();
      new import_obsidian.Notice("Failed to send message");
      console.error("Chat error:", error);
    }
  }
  updateChatMessages(messages) {
    if (!this.chatEl)
      return;
    this.chatEl.empty();
    messages.forEach((msg) => this.addMessageToChat(msg.role, msg.content));
    this.chatEl.scrollTop = this.chatEl.scrollHeight;
  }
  addMessageToChat(role, content) {
    const messageEl = this.chatEl.createDiv("ai-plugin-chat-message");
    messageEl.addClass(role);
    const bubbleEl = messageEl.createDiv("ai-plugin-chat-bubble");
    bubbleEl.setText(content);
  }
  addTypingIndicator() {
    const messageEl = this.chatEl.createDiv("ai-plugin-chat-message assistant");
    const bubbleEl = messageEl.createDiv("ai-plugin-chat-bubble");
    bubbleEl.createDiv("ai-plugin-typing-indicator");
    this.chatEl.scrollTop = this.chatEl.scrollHeight;
    return messageEl;
  }
  async enhanceCurrentNote(type) {
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active file");
      return;
    }
    const content = await this.app.vault.read(file);
    let result;
    try {
      switch (type) {
        case "clean":
          result = await this.plugin.textCleaner.cleanText(content);
          break;
        case "title":
          result = await this.plugin.titleSuggester.suggestTitle(file);
          break;
        case "tags":
          result = await this.plugin.tagSuggester.suggestTags(file, content);
          break;
        case "all":
          const [cleanContent, titleSuggestion, tags] = await Promise.all([
            this.plugin.textCleaner.cleanText(content),
            this.plugin.titleSuggester.suggestTitle(file),
            this.plugin.tagSuggester.suggestTags(file, content)
          ]);
          result = {
            content: cleanContent,
            title: titleSuggestion.title,
            tags
          };
          break;
      }
      new EnhancementPreviewModal(this.app, {
        original: content,
        enhanced: result,
        type
      }, async (accepted) => {
        if (accepted) {
          await this.applyEnhancements(file, result, type);
          new import_obsidian.Notice("Note enhanced successfully");
        }
      }).open();
    } catch (error) {
      console.error("Error enhancing note:", error);
      new import_obsidian.Notice("Failed to enhance note");
    }
  }
  async applyEnhancements(file, result, type) {
    let content = await this.app.vault.read(file);
    switch (type) {
      case "clean":
        await this.app.vault.modify(file, result);
        break;
      case "title":
        await this.app.vault.rename(file, `${result.title}.md`);
        break;
      case "tags":
        const frontmatter = this.extractFrontmatter(content);
        frontmatter.tags = result;
        content = this.updateFrontmatter(content, frontmatter);
        await this.app.vault.modify(file, content);
        break;
      case "all":
        await this.app.vault.rename(file, `${result.title}.md`);
        const allFrontmatter = this.extractFrontmatter(content);
        allFrontmatter.tags = result.tags;
        content = this.updateFrontmatter(result.content, allFrontmatter);
        await this.app.vault.modify(file, content);
        break;
    }
  }
  extractFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match)
      return {};
    try {
      const frontmatter = {};
      const lines = match[1].split("\n");
      for (const line of lines) {
        const [key, ...values] = line.split(":");
        if (key && values.length) {
          frontmatter[key.trim()] = values.join(":").trim();
        }
      }
      return frontmatter;
    } catch (e) {
      return {};
    }
  }
  updateFrontmatter(content, frontmatter) {
    const yaml = Object.entries(frontmatter).map(([key, value]) => `${key}: ${value}`).join("\n");
    const existingFrontmatter = content.match(/^---\n[\s\S]*?\n---\n/);
    if (existingFrontmatter) {
      return content.replace(existingFrontmatter[0], `---
${yaml}
---
`);
    }
    return `---
${yaml}
---

${content}`;
  }
  drawEnhanceTab(container) {
    const section = container.createDiv("ai-plugin-section");
    section.createEl("h3", { text: "Enhance Note" });
    const actionsDiv = section.createDiv("ai-plugin-actions");
    this.createActionButton(actionsDiv, "Clean Text", "edit-3", () => {
      this.enhanceCurrentNote("clean");
    });
    this.createActionButton(actionsDiv, "Suggest Title", "type", () => {
      this.enhanceCurrentNote("title");
    });
    this.createActionButton(actionsDiv, "Suggest Tags", "tag", () => {
      this.enhanceCurrentNote("tags");
    });
    this.createActionButton(actionsDiv, "Enhance All", "zap", () => {
      this.enhanceCurrentNote("all");
    });
  }
  createProcessingOption(container, label) {
    const option = container.createDiv("ai-plugin-processing-option");
    const checkbox = option.createEl("input", {
      type: "checkbox",
      cls: "ai-plugin-checkbox"
    });
    option.createEl("label", { text: label });
  }
  async processInbox() {
    if (!this.selectedInboxPath) {
      new import_obsidian.Notice("Please select an inbox folder");
      return;
    }
    try {
      await this.plugin.inboxProcessor.processFolder(this.selectedInboxPath);
      new import_obsidian.Notice("Inbox processing completed");
    } catch (error) {
      new import_obsidian.Notice(`Error processing inbox: ${error.message}`);
    }
  }
  drawInboxTab(container) {
    const section = container.createDiv("ai-plugin-section");
    section.createEl("h3", { text: "Inbox Processing" });
    const folderSelect = section.createDiv("ai-plugin-folder-select");
    folderSelect.createEl("label", { text: "Select Inbox Folder" });
    const input = new import_obsidian.TextComponent(folderSelect);
    input.setValue(this.selectedInboxPath);
    input.onChange((value) => this.selectedInboxPath = value);
    const optionsDiv = section.createDiv("ai-plugin-inbox-options");
    this.createProcessingOption(optionsDiv, "Clean Text");
    this.createProcessingOption(optionsDiv, "Suggest Titles");
    this.createProcessingOption(optionsDiv, "Add Tags");
    this.createProcessingOption(optionsDiv, "Move Files");
    this.createActionButton(section, "Process Inbox", "inbox", () => this.processInbox());
  }
  async showNoteSelector() {
    new import_obsidian.Notice("Note selection not implemented");
  }
};
var AtomicNotesPreviewModal = class extends import_obsidian.Modal {
  constructor(app, notes, onConfirm) {
    super(app);
    this.notes = notes;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-preview-modal");
    const content = contentEl.createDiv("ai-plugin-preview-content");
    this.notes.forEach((note, index) => {
      const notePreview = content.createDiv("ai-plugin-note-preview");
      notePreview.createEl("h4", { text: `Note ${index + 1}: ${note.title}` });
      notePreview.createEl("pre", { text: note.content });
    });
    const actions = contentEl.createDiv("ai-plugin-preview-actions");
    this.createActionButton(actions, "Create Notes", () => {
      this.onConfirm(true);
      this.close();
    });
    this.createActionButton(actions, "Cancel", () => {
      this.onConfirm(false);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createActionButton(container, text, onClick) {
    const button = container.createEl("button", {
      cls: "ai-plugin-button",
      text
    });
    button.addEventListener("click", onClick);
  }
};
var SimilarNotesModal = class extends import_obsidian.Modal {
  constructor(app, results) {
    super(app);
    this.results = results;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-similar-notes-modal");
    const content = contentEl.createDiv("ai-plugin-similar-notes-content");
    this.results.forEach((result) => {
      const noteDiv = content.createDiv("ai-plugin-similar-note");
      noteDiv.createEl("h4", { text: result.file.basename });
      noteDiv.createEl("div", {
        text: `Similarity: ${(result.similarity * 100).toFixed(1)}%`,
        cls: "ai-plugin-similarity-score"
      });
      if (result.relevantContent) {
        noteDiv.createEl("pre", { text: result.relevantContent });
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConceptsModal = class extends import_obsidian.Modal {
  constructor(app, concepts) {
    super(app);
    this.concepts = concepts;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-concepts-modal");
    const content = contentEl.createDiv("ai-plugin-concepts-content");
    if (this.concepts.keywords) {
      const keywordsDiv = content.createDiv("ai-plugin-keywords");
      keywordsDiv.createEl("h4", { text: "Key Concepts" });
      this.concepts.keywords.forEach((keyword, index) => {
        const score = this.concepts.relevance[index];
        const keywordDiv = keywordsDiv.createDiv("ai-plugin-keyword");
        keywordDiv.createEl("span", { text: keyword });
        keywordDiv.createEl("span", {
          text: `${(score * 100).toFixed(1)}%`,
          cls: "ai-plugin-keyword-score"
        });
      });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var TagSuggestionModal = class extends import_obsidian.Modal {
  constructor(app, suggestedTags, callback) {
    super(app);
    this.suggestedTags = suggestedTags;
  }
};
var TitleSuggestionModal = class extends import_obsidian.Modal {
  constructor(app, suggestedTitle, callback) {
    super(app);
    this.suggestedTitle = suggestedTitle;
  }
};
var PreviewModal = class extends import_obsidian.Modal {
  constructor(app, options, onConfirm) {
    super(app);
    this.options = options;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-preview-modal");
    const header = contentEl.createEl("h3", {
      text: this.options.type === "path" ? "Suggested File Location" : "Preview Changes"
    });
    const content = contentEl.createDiv("ai-plugin-preview-content");
    const originalSection = content.createDiv("ai-plugin-preview-section");
    originalSection.createEl("h4", { text: "Original" });
    originalSection.createEl("pre", {
      text: this.options.original,
      cls: "ai-plugin-preview-text"
    });
    const modifiedSection = content.createDiv("ai-plugin-preview-section");
    modifiedSection.createEl("h4", { text: "Modified" });
    modifiedSection.createEl("pre", {
      text: this.options.modified,
      cls: "ai-plugin-preview-text"
    });
    if (this.options.type === "content") {
      this.highlightDifferences(originalSection.querySelector("pre"), modifiedSection.querySelector("pre"));
    }
    const actions = contentEl.createDiv("ai-plugin-preview-actions");
    const acceptBtn = actions.createEl("button", {
      cls: "ai-plugin-button mod-cta",
      text: this.options.type === "path" ? "Move File" : "Accept Changes"
    });
    acceptBtn.addEventListener("click", () => {
      this.onConfirm(true);
      this.close();
    });
    const cancelBtn = actions.createEl("button", {
      cls: "ai-plugin-button",
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.onConfirm(false);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  highlightDifferences(originalEl, modifiedEl) {
    const originalText = originalEl.textContent || "";
    const modifiedText = modifiedEl.textContent || "";
    const originalWords = originalText.split(/\s+/);
    const modifiedWords = modifiedText.split(/\s+/);
    let originalHtml = "";
    let modifiedHtml = "";
    const maxLen = Math.max(originalWords.length, modifiedWords.length);
    for (let i = 0; i < maxLen; i++) {
      const originalWord = originalWords[i] || "";
      const modifiedWord = modifiedWords[i] || "";
      if (originalWord !== modifiedWord) {
        originalHtml += originalWord ? `<span class="ai-plugin-deleted">${originalWord}</span> ` : "";
        modifiedHtml += modifiedWord ? `<span class="ai-plugin-added">${modifiedWord}</span> ` : "";
      } else {
        originalHtml += `${originalWord} `;
        modifiedHtml += `${modifiedWord} `;
      }
    }
    originalEl.innerHTML = originalHtml.trim();
    modifiedEl.innerHTML = modifiedHtml.trim();
  }
};
var FileBrowserModal = class extends import_obsidian.Modal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-file-browser-modal");
    this.searchInput = new import_obsidian.TextComponent(contentEl).setPlaceholder("Search notes...").onChange(this.updateSearch.bind(this));
    this.results = contentEl.createDiv("ai-plugin-file-browser-results");
    this.updateSearch("");
  }
  async updateSearch(query) {
    this.results.empty();
    const files = this.app.vault.getMarkdownFiles();
    const filtered = query ? files.filter((file) => file.basename.toLowerCase().includes(query.toLowerCase())) : files;
    filtered.slice(0, 50).forEach((file) => {
      const item = this.results.createDiv("ai-plugin-file-browser-item");
      item.setText(file.basename);
      item.addEventListener("click", () => {
        this.onSelect(file);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EnhancementPreviewModal = class extends import_obsidian.Modal {
  constructor(app, preview, onConfirm) {
    super(app);
    this.preview = preview;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-preview-modal");
    const content = contentEl.createDiv("ai-plugin-preview-content");
    const originalDiv = content.createDiv("ai-plugin-preview-original");
    originalDiv.createEl("h4", { text: "Current" });
    originalDiv.createEl("pre", { text: this.preview.original });
    const modifiedDiv = content.createDiv("ai-plugin-preview-modified");
    modifiedDiv.createEl("h4", { text: "Enhanced" });
    if (typeof this.preview.enhanced === "string") {
      modifiedDiv.createEl("pre", { text: this.preview.enhanced });
    } else {
      const enhancedContent = this.formatEnhancedContent(this.preview.enhanced, this.preview.type);
      modifiedDiv.createEl("pre", { text: enhancedContent });
    }
    const actions = contentEl.createDiv("ai-plugin-preview-actions");
    const acceptBtn = actions.createEl("button", {
      cls: "ai-plugin-button",
      text: "Accept"
    });
    acceptBtn.addEventListener("click", () => {
      this.onConfirm(true);
      this.close();
    });
    const rejectBtn = actions.createEl("button", {
      cls: "ai-plugin-button",
      text: "Cancel"
    });
    rejectBtn.addEventListener("click", () => {
      this.onConfirm(false);
      this.close();
    });
  }
  formatEnhancedContent(enhanced, type) {
    switch (type) {
      case "title":
        return `New Title: ${enhanced.title}
Confidence: ${(enhanced.confidence * 100).toFixed(1)}%

Alternatives:
${enhanced.alternates.join("\n")}`;
      case "tags":
        return `Suggested Tags:
${enhanced.join(", ")}`;
      case "all":
        return `Title: ${enhanced.title}
Tags: ${enhanced.tags.join(", ")}

Content:
${enhanced.content}`;
      default:
        return JSON.stringify(enhanced, null, 2);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modelManager.ts
var import_axios = __toModule(require_axios2());
var ModelProvider;
(function(ModelProvider2) {
  ModelProvider2["Ollama"] = "ollama";
  ModelProvider2["OpenAI"] = "openai";
})(ModelProvider || (ModelProvider = {}));
var ModelManager = class {
  constructor(provider, model, endpoint) {
    this.isInitialized = false;
    this.DEFAULT_OLLAMA_MODEL = "llama2";
    this.DEFAULT_OPENAI_MODEL = "gpt-3.5-turbo";
    this.provider = provider;
    this.model = model;
    this.endpoint = endpoint;
  }
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const availableModels = await this.getAvailableModels();
      if (availableModels.length === 0) {
        throw new Error("No models available. Please ensure Ollama is running and has models installed.");
      }
      if (!availableModels.includes(this.model)) {
        console.log(`Model ${this.model} not available, using ${availableModels[0]}`);
        this.model = availableModels[0];
      }
      this.isInitialized = true;
    } catch (error) {
      console.error("Failed to initialize ModelManager:", error);
      throw error;
    }
  }
  setProvider(provider) {
    this.provider = provider;
    this.isInitialized = false;
  }
  setModel(model) {
    this.model = model;
    this.isInitialized = false;
  }
  setEndpoint(endpoint) {
    this.endpoint = endpoint;
    this.isInitialized = false;
  }
  getCurrentModel() {
    return this.model;
  }
  async getAvailableModels() {
    try {
      const response = await import_axios.default.get(`${this.endpoint}/api/tags`);
      if (response.data && Array.isArray(response.data.models)) {
        return response.data.models.map((model) => model.name);
      }
      return [];
    } catch (error) {
      console.error("Failed to fetch Ollama models:", error);
      return [];
    }
  }
  async getOllamaModels() {
    try {
      const response = await import_axios.default.get(`${this.endpoint}/api/tags`);
      if (response.data && Array.isArray(response.data.models)) {
        return response.data.models.map((model) => model.name);
      }
      return [];
    } catch (error) {
      console.error("Failed to fetch Ollama models:", error);
      return [];
    }
  }
  async downloadOllamaModel(modelName) {
    try {
      console.log(`Starting download of model: ${modelName}`);
      const response = await import_axios.default.post(`${this.endpoint}/api/pull`, {
        name: modelName
      }, {
        timeout: 3e5
      });
      console.log(`Successfully downloaded model: ${modelName}`);
      return true;
    } catch (error) {
      console.error(`Failed to download Ollama model ${modelName}:`, error);
      return false;
    }
  }
  async generateEmbedding(text) {
    await this.initialize();
    switch (this.provider) {
      case ModelProvider.Ollama:
        return this.generateOllamaEmbedding(text);
      case ModelProvider.OpenAI:
        return this.generateOpenAIEmbedding(text);
      default:
        throw new Error("Unsupported model provider");
    }
  }
  async generateText(prompt) {
    await this.initialize();
    try {
      const response = await import_axios.default.post(`${this.endpoint}/api/generate`, {
        model: this.model,
        prompt,
        stream: false
      });
      return response.data.response;
    } catch (error) {
      console.error("Failed to generate text:", error);
      throw error;
    }
  }
  async generateOllamaEmbedding(text) {
    try {
      const response = await import_axios.default.post(`${this.endpoint}/api/embeddings`, {
        model: this.model,
        prompt: text
      });
      return response.data.embedding;
    } catch (error) {
      console.error("Failed to generate Ollama embedding:", error);
      throw error;
    }
  }
  async generateOpenAIEmbedding(text) {
    try {
      const response = await import_axios.default.post("https://api.openai.com/v1/embeddings", {
        model: "text-embedding-ada-002",
        input: text
      }, {
        headers: {
          "Authorization": `Bearer ${this.endpoint}`,
          "Content-Type": "application/json"
        }
      });
      return response.data.data[0].embedding;
    } catch (error) {
      console.error("Failed to generate OpenAI embedding:", error);
      throw error;
    }
  }
  async generateOllamaText(prompt) {
    try {
      const response = await import_axios.default.post(`${this.endpoint}/api/generate`, {
        model: this.model,
        prompt,
        stream: true
      }, {
        responseType: "stream"
      });
      let fullResponse = "";
      for await (const chunk of response.data) {
        const lines = chunk.toString("utf8").split("\n");
        for (const line of lines) {
          if (line.trim() !== "") {
            try {
              const data = JSON.parse(line);
              if (data.response) {
                fullResponse += data.response;
              }
              if (data.done) {
                return fullResponse.trim();
              }
            } catch (err) {
              console.error("Error parsing JSON:", err);
            }
          }
        }
      }
      return fullResponse.trim();
    } catch (error) {
      console.error("Failed to generate Ollama text:", error);
      throw error;
    }
  }
  async generateOpenAIText(prompt) {
    try {
      const response = await import_axios.default.post("https://api.openai.com/v1/chat/completions", {
        model: this.model,
        messages: [{ role: "user", content: prompt }]
      }, {
        headers: {
          "Authorization": `Bearer ${this.endpoint}`,
          "Content-Type": "application/json"
        }
      });
      return response.data.choices[0].message.content.trim();
    } catch (error) {
      console.error("Failed to generate OpenAI text:", error);
      throw error;
    }
  }
};

// node_modules/idb/build/index.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var transactionDoneMap = new WeakMap();
var transformCache = new WeakMap();
var reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(this.request);
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(event.oldVersion, event.newVersion, event));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
var advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
var methodMap = {};
var advanceResults = new WeakMap();
var ittrProxiedCursorToOriginalProxy = new WeakMap();
var cursorIteratorTraps = {
  get(target, prop) {
    if (!advanceMethodProps.includes(prop))
      return target[prop];
    let cachedFunc = methodMap[prop];
    if (!cachedFunc) {
      cachedFunc = methodMap[prop] = function(...args) {
        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
      };
    }
    return cachedFunc;
  }
};
async function* iterate(...args) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get(target, prop, receiver) {
    if (isIteratorProp(target, prop))
      return iterate;
    return oldTraps.get(target, prop, receiver);
  },
  has(target, prop) {
    return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  }
}));

// src/db.ts
var DatabaseManager = class {
  async init() {
    this.db = await openDB("ai-plugin-db", 1, {
      upgrade(db) {
        const embeddingsStore = db.createObjectStore("embeddings", { keyPath: "id" });
        embeddingsStore.createIndex("by-file", "file");
        embeddingsStore.createIndex("by-chunk", ["file", "chunk"]);
      }
    });
  }
  async storeEmbeddings(embeddings) {
    const tx = this.db.transaction("embeddings", "readwrite");
    for (const embedding of embeddings) {
      await tx.store.put(embedding);
    }
    await tx.done;
  }
  async getEmbeddingsForFile(file) {
    return this.db.getAllFromIndex("embeddings", "by-file", file);
  }
  async getEmbeddingForChunk(file, chunk) {
    return this.db.getFromIndex("embeddings", "by-chunk", [file, chunk]);
  }
  async getAllEmbeddings() {
    return this.db.getAll("embeddings");
  }
  async deleteEmbeddingsForFile(file) {
    const tx = this.db.transaction("embeddings", "readwrite");
    const index = tx.store.index("by-file");
    let cursor = await index.openCursor(file);
    while (cursor) {
      await cursor.delete();
      cursor = await cursor.continue();
    }
    await tx.done;
  }
};

// src/embeddings.ts
var EmbeddingManager = class {
  constructor(vault, modelManager, databaseManager, cacheExpiration) {
    this.CHUNK_SIZE = 512;
    this.CHUNK_OVERLAP = 128;
    this.vault = vault;
    this.modelManager = modelManager;
    this.databaseManager = databaseManager;
    this.cacheExpiration = cacheExpiration;
  }
  async generateEmbedding(text) {
    return this.modelManager.generateEmbedding(text);
  }
  async generateEmbeddingsForFile(file) {
    const content = await this.vault.read(file);
    const chunks = this.chunkContent(content);
    const embeddings = [];
    for (let i = 0; i < chunks.length; i++) {
      const vector = await this.generateEmbedding(chunks[i]);
      embeddings.push({
        id: `${file.path}-${i}`,
        vector,
        file: file.path,
        chunk: chunks[i],
        timestamp: Date.now()
      });
    }
    await this.databaseManager.deleteEmbeddingsForFile(file.path);
    await this.databaseManager.storeEmbeddings(embeddings);
    return embeddings;
  }
  async getEmbeddingsForFile(file) {
    const storedEmbeddings = await this.databaseManager.getEmbeddingsForFile(file.path);
    if (storedEmbeddings.length > 0 && this.isEmbeddingValid(storedEmbeddings[0])) {
      return storedEmbeddings;
    }
    return this.generateEmbeddingsForFile(file);
  }
  chunkContent(content) {
    const words = content.split(/\s+/);
    const chunks = [];
    let currentChunk = [];
    let currentLength = 0;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      currentChunk.push(word);
      currentLength += word.length + 1;
      if (currentLength >= this.CHUNK_SIZE) {
        chunks.push(currentChunk.join(" "));
        const overlapWords = currentChunk.slice(-Math.floor(this.CHUNK_OVERLAP / 5));
        currentChunk = overlapWords;
        currentLength = overlapWords.join(" ").length;
      }
    }
    if (currentChunk.length > 0) {
      chunks.push(currentChunk.join(" "));
    }
    return chunks.map((chunk) => this.cleanChunk(chunk));
  }
  cleanChunk(chunk) {
    return chunk.replace(/[#*_`~]/g, "").replace(/\[\[([^\]]+)\]\]/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").trim();
  }
  isEmbeddingValid(embedding) {
    return Date.now() - embedding.timestamp < this.cacheExpiration;
  }
};

// src/vaultQuerier.ts
var VaultQuerier = class {
  constructor(vault, embeddingManager, databaseManager) {
    this.DEFAULT_LIMIT = 5;
    this.DEFAULT_THRESHOLD = 0.7;
    this.CONTEXT_WINDOW = 100;
    this.vault = vault;
    this.embeddingManager = embeddingManager;
    this.databaseManager = databaseManager;
  }
  async queryVault(query, options = {}) {
    const {
      limit = this.DEFAULT_LIMIT,
      threshold = this.DEFAULT_THRESHOLD,
      includeContent = false,
      searchType = "semantic",
      categories = [],
      tags = [],
      dateRange
    } = options;
    let results = [];
    switch (searchType) {
      case "semantic":
        results = await this.semanticSearch(query, limit, threshold);
        break;
      case "hybrid":
        results = await this.hybridSearch(query, limit, threshold);
        break;
      case "exact":
        results = await this.exactSearch(query, limit);
        break;
    }
    results = await this.filterResults(results, { categories, tags, dateRange });
    if (includeContent) {
      results = await this.enrichResults(results, query);
    }
    return results;
  }
  async semanticSearch(query, limit, threshold) {
    var _a;
    const queryEmbedding = await this.embeddingManager.generateEmbedding(query);
    const allEmbeddings = await this.databaseManager.getAllEmbeddings();
    const results = new Map();
    for (const embedding of allEmbeddings) {
      const similarity = this.cosineSimilarity(queryEmbedding, embedding.vector);
      if (similarity < threshold)
        continue;
      const file = this.vault.getAbstractFileByPath(embedding.file);
      if (!file)
        continue;
      const existing = results.get(file.path);
      if (!existing || existing.similarity < similarity) {
        results.set(file.path, {
          file,
          similarity,
          matchingChunks: [embedding.chunk]
        });
      } else {
        (_a = existing.matchingChunks) == null ? void 0 : _a.push(embedding.chunk);
      }
    }
    return Array.from(results.values()).sort((a, b) => b.similarity - a.similarity).slice(0, limit);
  }
  async hybridSearch(query, limit, threshold) {
    const [semanticResults, exactResults] = await Promise.all([
      this.semanticSearch(query, limit * 2, threshold),
      this.exactSearch(query, limit * 2)
    ]);
    const combined = new Map();
    for (const result of [...semanticResults, ...exactResults]) {
      const existing = combined.get(result.file.path);
      if (!existing || existing.similarity < result.similarity) {
        combined.set(result.file.path, result);
      }
    }
    return Array.from(combined.values()).sort((a, b) => b.similarity - a.similarity).slice(0, limit);
  }
  async exactSearch(query, limit) {
    const results = [];
    const files = this.vault.getMarkdownFiles();
    const queryTerms = query.toLowerCase().split(/\s+/);
    for (const file of files) {
      const content = await this.vault.read(file);
      const contentLower = content.toLowerCase();
      let matchCount = 0;
      for (const term of queryTerms) {
        const regex = new RegExp(term, "gi");
        const matches = contentLower.match(regex);
        if (matches) {
          matchCount += matches.length;
        }
      }
      if (matchCount > 0) {
        results.push({
          file,
          similarity: matchCount / (content.length / 100),
          relevantContent: this.extractRelevantContent(content, query)
        });
      }
    }
    return results.sort((a, b) => b.similarity - a.similarity).slice(0, limit);
  }
  async filterResults(results, filters) {
    const filtered = [];
    for (const result of results) {
      const content = await this.vault.read(result.file);
      const frontmatter = this.extractFrontmatter(content);
      if (this.matchesFilters(frontmatter, filters)) {
        filtered.push(result);
      }
    }
    return filtered;
  }
  async enrichResults(results, query) {
    return Promise.all(results.map(async (result) => {
      const content = await this.vault.read(result.file);
      return {
        ...result,
        relevantContent: this.extractRelevantContent(content, query)
      };
    }));
  }
  cosineSimilarity(vec1, vec2) {
    const dotProduct = vec1.reduce((sum, val, i) => sum + val * vec2[i], 0);
    const mag1 = Math.sqrt(vec1.reduce((sum, val) => sum + val * val, 0));
    const mag2 = Math.sqrt(vec2.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (mag1 * mag2);
  }
  extractFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match)
      return {};
    try {
      const frontmatter = {};
      const lines = match[1].split("\n");
      for (const line of lines) {
        const [key, ...values] = line.split(":");
        if (key && values.length) {
          frontmatter[key.trim()] = values.join(":").trim();
        }
      }
      return frontmatter;
    } catch (e) {
      return {};
    }
  }
  matchesFilters(frontmatter, filters) {
    const { categories, tags, dateRange } = filters;
    if ((categories == null ? void 0 : categories.length) && !categories.includes(frontmatter.category)) {
      return false;
    }
    if (tags == null ? void 0 : tags.length) {
      const noteTags = (frontmatter.tags || "").split(",").map((t) => t.trim());
      if (!tags.some((tag) => noteTags.includes(tag))) {
        return false;
      }
    }
    if (dateRange) {
      const noteDate = new Date(frontmatter.date);
      if (dateRange.start && noteDate < dateRange.start)
        return false;
      if (dateRange.end && noteDate > dateRange.end)
        return false;
    }
    return true;
  }
  extractRelevantContent(content, query) {
    const lines = content.split("\n");
    const queryTerms = query.toLowerCase().split(/\s+/);
    let bestMatch = { score: 0, index: 0 };
    for (let i = 0; i < lines.length; i++) {
      const windowText = lines.slice(i, i + 3).join(" ").toLowerCase();
      let score = 0;
      for (const term of queryTerms) {
        if (windowText.includes(term)) {
          score += 1;
        }
      }
      if (score > bestMatch.score) {
        bestMatch = { score, index: i };
      }
    }
    const start = Math.max(0, bestMatch.index - 1);
    const end = Math.min(lines.length, bestMatch.index + 4);
    return lines.slice(start, end).join("\n");
  }
};

// src/atomizer.ts
var Atomizer = class {
  constructor(vault, modelManager) {
    this.MIN_CHUNK_SIZE = 100;
    this.MAX_CHUNK_SIZE = 2e3;
    this.vault = vault;
    this.modelManager = modelManager;
  }
  async atomizeNote(file) {
    const content = await this.vault.read(file);
    const { sections, references } = this.parseContent(content);
    const atomicNotes = [];
    for (const section of sections) {
      if (section.length < this.MIN_CHUNK_SIZE)
        continue;
      const conceptPrompt = `Extract the main concept from this text section and return it as a single, concise phrase:

${section}`;
      const concept = await this.modelManager.generateText(conceptPrompt);
      const analysisPrompt = `Analyze this text about "${concept}" and generate:
1. A clear title (as a string)
2. Relevant tags (as a JSON array)
3. A well-structured note (as a string)
Format the response as a JSON object with "title", "tags", and "content" fields.

Text to analyze:
${section}`;
      const response = await this.modelManager.generateText(analysisPrompt);
      const analysis = JSON.parse(response);
      atomicNotes.push({
        title: this.sanitizeTitle(analysis.title),
        content: this.formatContent(analysis.content, file.basename),
        tags: analysis.tags,
        references
      });
    }
    return atomicNotes;
  }
  parseContent(content) {
    const references = new Set();
    const sections = [];
    let currentSection = "";
    content = content.replace(/^---\n[\s\S]*?\n---\n/, "");
    const lines = content.split("\n");
    for (const line of lines) {
      if (line.match(/^#{1,6}\s/)) {
        if (currentSection) {
          sections.push(currentSection.trim());
        }
        currentSection = line + "\n";
      } else {
        currentSection += line + "\n";
        const wikiLinks = line.match(/\[\[(.*?)\]\]/g);
        if (wikiLinks) {
          wikiLinks.forEach((link) => {
            references.add(link.slice(2, -2).split("|")[0]);
          });
        }
        const mdLinks = line.match(/\[([^\]]+)\]\(([^\)]+)\)/g);
        if (mdLinks) {
          mdLinks.forEach((link) => {
            const match = link.match(/\[([^\]]+)\]\(([^\)]+)\)/);
            if (match)
              references.add(match[1]);
          });
        }
      }
    }
    if (currentSection) {
      sections.push(currentSection.trim());
    }
    return {
      sections: this.balanceSections(sections),
      references: Array.from(references)
    };
  }
  balanceSections(sections) {
    const balanced = [];
    let currentSection = "";
    for (const section of sections) {
      if (currentSection.length + section.length <= this.MAX_CHUNK_SIZE) {
        currentSection += (currentSection ? "\n\n" : "") + section;
      } else {
        if (currentSection)
          balanced.push(currentSection);
        currentSection = section;
      }
    }
    if (currentSection)
      balanced.push(currentSection);
    return balanced;
  }
  sanitizeTitle(title) {
    return title.replace(/[/\\?%*:|"<>]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
  }
  formatContent(content, sourceNote) {
    const timestamp = new Date().toISOString().split("T")[0];
    return `---
created: ${timestamp}
source: [[${sourceNote}]]
tags: ${this.formatTags(this.extractTags(content))}
---

${content}`;
  }
  extractTags(content) {
    const tags = new Set();
    const tagRegex = /#([a-zA-Z0-9_-]+)/g;
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.add(match[1]);
    }
    return Array.from(tags);
  }
  formatTags(tags) {
    return tags.map((tag) => `#${tag}`).join(" ");
  }
};

// src/nlpManager.ts
var NLPManager = class {
  constructor(modelManager) {
    this.MAX_CHUNK_SIZE = 1e3;
    this.modelManager = modelManager;
  }
  async performTask(task, text) {
    const chunks = this.chunkText(text);
    const results = await Promise.all(chunks.map((chunk) => this.processChunk(task, chunk)));
    return this.aggregateResults(task, results);
  }
  chunkText(text) {
    if (text.length <= this.MAX_CHUNK_SIZE)
      return [text];
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    const chunks = [];
    let currentChunk = "";
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length <= this.MAX_CHUNK_SIZE) {
        currentChunk += sentence;
      } else {
        if (currentChunk)
          chunks.push(currentChunk);
        currentChunk = sentence;
      }
    }
    if (currentChunk)
      chunks.push(currentChunk);
    return chunks;
  }
  async processChunk(task, text) {
    const prompt = this.createPrompt(task, text);
    const response = await this.modelManager.generateText(prompt);
    try {
      return JSON.parse(response);
    } catch (e) {
      return { error: "Failed to parse response", raw: response };
    }
  }
  createPrompt(task, text) {
    var _a;
    const prompts = {
      sentiment: `Analyze the sentiment of the following text. Return a JSON object with "sentiment" (positive/negative/neutral), "score" (0-1), and "keywords" (array of influential words):

${text}`,
      summary: `Summarize the following text in a concise way. Return a JSON object with "summary" (string) and "keyPoints" (array):

${text}`,
      keywords: `Extract key phrases and topics from the following text. Return a JSON object with "keywords" (array) and "relevance" (array of scores 0-1):

${text}`,
      entities: `Extract named entities from the following text. Return a JSON object with "entities" (array of objects with "text", "type", and "confidence"):

${text}`,
      topics: `Identify main topics and themes in the following text. Return a JSON object with "topics" (array) and "hierarchy" (object showing topic relationships):

${text}`
    };
    if (task.type === "custom" && ((_a = task.options) == null ? void 0 : _a.prompt)) {
      return task.options.prompt.replace("{text}", text);
    }
    return prompts[task.type] || prompts.keywords;
  }
  aggregateResults(task, results) {
    switch (task.type) {
      case "sentiment":
        return this.aggregateSentiment(results);
      case "summary":
        return this.aggregateSummary(results);
      case "keywords":
        return this.aggregateKeywords(results);
      case "entities":
        return this.aggregateEntities(results);
      case "topics":
        return this.aggregateTopics(results);
      default:
        return {
          task: task.type,
          result: results[0]
        };
    }
  }
  aggregateSentiment(results) {
    const scores = results.map((r) => r.score);
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const keywords = new Set(results.flatMap((r) => r.keywords));
    return {
      task: "sentiment",
      result: {
        sentiment: avgScore > 0.6 ? "positive" : avgScore < 0.4 ? "negative" : "neutral",
        score: avgScore,
        keywords: Array.from(keywords)
      },
      confidence: Math.min(...results.map((r) => r.confidence || 1))
    };
  }
  aggregateSummary(results) {
    const keyPoints = new Set(results.flatMap((r) => r.keyPoints));
    return {
      task: "summary",
      result: {
        summary: results[0].summary,
        keyPoints: Array.from(keyPoints)
      }
    };
  }
  aggregateKeywords(results) {
    const keywordMap = new Map();
    results.forEach((r) => {
      r.keywords.forEach((kw, i) => {
        const score = r.relevance[i] || 1;
        keywordMap.set(kw, (keywordMap.get(kw) || 0) + score);
      });
    });
    const sortedKeywords = Array.from(keywordMap.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10);
    return {
      task: "keywords",
      result: {
        keywords: sortedKeywords.map(([kw]) => kw),
        relevance: sortedKeywords.map(([, score]) => score / results.length)
      }
    };
  }
  aggregateEntities(results) {
    const entityMap = new Map();
    results.forEach((r) => {
      r.entities.forEach((entity) => {
        const key = `${entity.text}|${entity.type}`;
        const existing = entityMap.get(key);
        if (existing) {
          existing.confidence += entity.confidence;
          existing.count += 1;
        } else {
          entityMap.set(key, {
            type: entity.type,
            confidence: entity.confidence,
            count: 1
          });
        }
      });
    });
    const entities = Array.from(entityMap.entries()).map(([key, value]) => ({
      text: key.split("|")[0],
      type: value.type,
      confidence: value.confidence / value.count
    }));
    return {
      task: "entities",
      result: { entities }
    };
  }
  aggregateTopics(results) {
    const topics = new Set(results.flatMap((r) => r.topics));
    const hierarchy = results[0].hierarchy;
    return {
      task: "topics",
      result: {
        topics: Array.from(topics),
        hierarchy
      }
    };
  }
};

// src/textCleaner.ts
var TextCleaner = class {
  constructor(modelManager) {
    this.DEFAULT_OPTIONS = {
      fixGrammar: true,
      fixSpelling: true,
      improvePunctuation: true,
      improveFormatting: true,
      preserveLinks: true,
      preserveFrontmatter: true,
      ignoreExcalidraw: false
    };
    this.modelManager = modelManager;
  }
  async cleanText(text, options = {}) {
    const finalOptions = { ...this.DEFAULT_OPTIONS, ...options };
    const { frontmatter, content } = this.separateFrontmatter(text);
    const { cleanContent, excalidrawBlocks } = finalOptions.ignoreExcalidraw ? this.extractExcalidrawBlocks(content) : { cleanContent: content, excalidrawBlocks: [] };
    const { text: processedText, markers } = finalOptions.preserveLinks ? this.preserveSpecialSyntax(cleanContent) : { text: cleanContent, markers: [] };
    const sections = this.splitIntoSections(processedText);
    const cleanedSections = await Promise.all(sections.map((section) => this.cleanSection(section, finalOptions)));
    let cleanedText = cleanedSections.join("\n\n");
    cleanedText = this.restoreSpecialSyntax(cleanedText, markers);
    if (finalOptions.ignoreExcalidraw) {
      cleanedText = this.restoreExcalidrawBlocks(cleanedText, excalidrawBlocks);
    }
    return finalOptions.preserveFrontmatter && frontmatter ? `${frontmatter}

${cleanedText}` : cleanedText;
  }
  extractExcalidrawBlocks(text) {
    const excalidrawBlocks = [];
    let cleanContent = text;
    const excalidrawRegex = /```json excalidraw\n([\s\S]*?)```/g;
    let match;
    let index = 0;
    while ((match = excalidrawRegex.exec(text)) !== null) {
      const placeholder = `EXCALIDRAW_BLOCK_${index}`;
      excalidrawBlocks.push({
        placeholder,
        content: match[0]
      });
      cleanContent = cleanContent.replace(match[0], placeholder);
      index++;
    }
    return { cleanContent, excalidrawBlocks };
  }
  restoreExcalidrawBlocks(text, blocks) {
    let restoredText = text;
    blocks.forEach((block) => {
      restoredText = restoredText.replace(block.placeholder, block.content);
    });
    return restoredText;
  }
  separateFrontmatter(text) {
    const match = text.match(/^(---\n[\s\S]*?\n---\n)([\s\S]*)$/);
    if (match) {
      return { frontmatter: match[1], content: match[2] };
    }
    return { frontmatter: null, content: text };
  }
  preserveSpecialSyntax(text) {
    const markers = [];
    let processedText = text;
    const syntaxPatterns = [
      { pattern: /\[\[([^\]]+)\]\]/g, prefix: "WIKILINK" },
      { pattern: /\[([^\]]+)\]\(([^\)]+)\)/g, prefix: "MDLINK" },
      { pattern: /`[^`]+`/g, prefix: "CODE" },
      { pattern: /```[\s\S]*?```/g, prefix: "CODEBLOCK" },
      { pattern: /\$\$[\s\S]*?\$\$/g, prefix: "MATH" },
      { pattern: /\$[^$\n]+\$/g, prefix: "INLINEMATH" }
    ];
    syntaxPatterns.forEach(({ pattern, prefix }) => {
      processedText = processedText.replace(pattern, (match) => {
        const id = `${prefix}_${markers.length}`;
        markers.push({ id, content: match });
        return id;
      });
    });
    return { text: processedText, markers };
  }
  restoreSpecialSyntax(text, markers) {
    let restoredText = text;
    markers.forEach(({ id, content }) => {
      restoredText = restoredText.replace(id, content);
    });
    return restoredText;
  }
  splitIntoSections(text) {
    return text.split(/(?:\n\n|\r\n\r\n)/).filter((section) => section.trim());
  }
  async cleanSection(section, options) {
    const prompt = this.createCleaningPrompt(section, options);
    try {
      const cleanedSection = await this.modelManager.generateText(prompt);
      return this.postProcessSection(cleanedSection, options);
    } catch (error) {
      console.error("Error cleaning section:", error);
      return section;
    }
  }
  createCleaningPrompt(section, options) {
    const tasks = [
      options.fixGrammar && "Fix any grammatical errors",
      options.fixSpelling && "Correct spelling mistakes",
      options.improvePunctuation && "Improve punctuation",
      options.improveFormatting && "Enhance formatting and structure"
    ].filter(Boolean).join(", ");
    return `Improve the following text by ${tasks}. Maintain the original meaning and tone. Return only the cleaned text:

${section}`;
  }
  postProcessSection(section, options) {
    let processed = section;
    if (options.improveFormatting) {
      processed = processed.replace(/\r\n/g, "\n");
      processed = processed.replace(/\s+([.,!?;:])/g, "$1").replace(/([.,!?;:])\s*/g, "$1 ").replace(/\s+/g, " ");
      processed = processed.replace(/(\*\*|__)(.*?)\1/g, " $1$2$1 ").replace(/(\*|_)(.*?)\1/g, " $1$2$1 ").trim();
    }
    return processed;
  }
};

// src/tagSuggester.ts
var TagSuggester = class {
  constructor(modelManager) {
    this.modelManager = modelManager;
  }
  async suggestTags(file, content) {
    const prompt = `Suggest relevant tags for the following note content. Return the tags as a JSON array of strings, without any symbols:

${content}`;
    try {
      const response = await this.modelManager.generateText(prompt);
      const suggestedTags = JSON.parse(response);
      return Array.isArray(suggestedTags) ? suggestedTags : [];
    } catch (error) {
      console.error("Error suggesting tags:", error);
      throw new Error("Failed to suggest tags");
    }
  }
};

// src/titleSuggester.ts
var TitleSuggester = class {
  constructor(app, modelManager, vaultQuerier) {
    this.MIN_CONTENT_LENGTH = 50;
    this.MAX_TITLE_LENGTH = 100;
    this.SIMILARITY_THRESHOLD = 0.8;
    this.app = app;
    this.modelManager = modelManager;
    this.vaultQuerier = vaultQuerier;
  }
  async suggestTitle(file) {
    const content = await this.app.vault.read(file);
    if (content.length < this.MIN_CONTENT_LENGTH) {
      throw new Error("Content too short for meaningful title suggestion");
    }
    const { frontmatter, mainContent } = this.extractFrontmatter(content);
    const existingTitles = await this.getExistingTitles();
    const similarNotes = await this.findSimilarNotes(file);
    const suggestion = await this.generateTitleSuggestion(mainContent, frontmatter, existingTitles, similarNotes);
    return this.validateAndRefineTitle(suggestion, existingTitles);
  }
  extractFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!match) {
      return { frontmatter: {}, mainContent: content };
    }
    try {
      const frontmatter = this.parseFrontmatter(match[1]);
      return { frontmatter, mainContent: match[2] };
    } catch (error) {
      console.error("Error parsing frontmatter:", error);
      return { frontmatter: {}, mainContent: content };
    }
  }
  parseFrontmatter(yaml) {
    const frontmatter = {};
    const lines = yaml.split("\n");
    for (const line of lines) {
      const [key, ...values] = line.split(":");
      if (key && values.length) {
        const value = values.join(":").trim();
        frontmatter[key.trim()] = value.startsWith("[") ? value.slice(1, -1).split(",").map((v) => v.trim()) : value;
      }
    }
    return frontmatter;
  }
  async getExistingTitles() {
    const files = this.app.vault.getMarkdownFiles();
    return new Set(files.map((file) => file.basename.toLowerCase()));
  }
  async findSimilarNotes(file) {
    const searchOptions = {
      limit: 5
    };
    const similarNotes = await this.vaultQuerier.queryVault(await this.app.vault.read(file), searchOptions);
    return similarNotes.map((result) => result.file.basename);
  }
  async generateTitleSuggestion(content, frontmatter, existingTitles, similarNotes) {
    const context = {
      tags: frontmatter.tags || [],
      category: frontmatter.category,
      similarTitles: similarNotes
    };
    const prompt = `Generate a title suggestion for the following content. Return a JSON object with:
- title: The main title suggestion
- confidence: A score from 0-1 indicating confidence
- alternates: Array of 2-3 alternative titles
- tags: Suggested tags
- category: Optional category

Context:
${JSON.stringify(context)}

Content:
${content.slice(0, 1e3)}`;
    const response = await this.modelManager.generateText(prompt);
    return JSON.parse(response);
  }
  validateAndRefineTitle(suggestion, existingTitles) {
    suggestion.title = this.truncateTitle(suggestion.title);
    suggestion.alternates = suggestion.alternates.map((title) => this.truncateTitle(title));
    if (existingTitles.has(suggestion.title.toLowerCase())) {
      const uniqueTitle = this.makeUnique(suggestion.title, existingTitles);
      suggestion.alternates.unshift(suggestion.title);
      suggestion.title = uniqueTitle;
      suggestion.confidence *= 0.9;
    }
    suggestion.tags = this.cleanTags(suggestion.tags);
    return suggestion;
  }
  truncateTitle(title) {
    if (title.length <= this.MAX_TITLE_LENGTH)
      return title;
    const truncated = title.slice(0, this.MAX_TITLE_LENGTH);
    const lastSpace = truncated.lastIndexOf(" ");
    return lastSpace > 0 ? truncated.slice(0, lastSpace) : truncated;
  }
  makeUnique(title, existingTitles) {
    let counter = 1;
    let uniqueTitle = title;
    while (existingTitles.has(uniqueTitle.toLowerCase())) {
      uniqueTitle = `${title} ${counter}`;
      counter++;
    }
    return uniqueTitle;
  }
  cleanTags(tags) {
    return tags.map((tag) => tag.toLowerCase().replace(/[^\w-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "")).filter((tag) => tag.length > 0).filter((tag, index, self) => self.indexOf(tag) === index);
  }
};

// src/notePathManager.ts
var NotePathManager = class {
  constructor(vault, rules) {
    this.vault = vault;
    this.rules = rules;
  }
  async getSuggestedPath(file) {
    const content = await this.vault.read(file);
    const frontmatter = this.extractFrontmatter(content);
    for (const rule of this.rules) {
      if (await this.matchesCriteria(content, frontmatter, rule.criteria)) {
        const targetPath = this.formatTargetPath(rule.targetPath, file, frontmatter);
        return targetPath;
      }
    }
    return null;
  }
  async checkAndMoveNote(file) {
    const suggestedPath = await this.getSuggestedPath(file);
    if (suggestedPath && file.path !== suggestedPath) {
      await this.moveNote(file, suggestedPath);
    }
  }
  async moveNote(file, newPath) {
    try {
      const targetDir = newPath.substring(0, newPath.lastIndexOf("/"));
      if (targetDir) {
        await this.ensureDirectory(targetDir);
      }
      await this.vault.rename(file, newPath);
    } catch (error) {
      console.error("Failed to move note:", error);
      throw new Error("Failed to move note");
    }
  }
  async ensureDirectory(path) {
    const dirs = path.split("/");
    let currentPath = "";
    for (const dir of dirs) {
      currentPath += (currentPath ? "/" : "") + dir;
      if (!await this.vault.adapter.exists(currentPath)) {
        await this.vault.createFolder(currentPath);
      }
    }
  }
  async matchesCriteria(content, frontmatter, criteria) {
    var _a;
    if (criteria.startsWith("tag:")) {
      const tag = criteria.substring(4);
      return ((_a = frontmatter == null ? void 0 : frontmatter.tags) == null ? void 0 : _a.includes(tag)) || content.includes(`#${tag}`);
    }
    if (criteria.startsWith("category:")) {
      const category = criteria.substring(9);
      return (frontmatter == null ? void 0 : frontmatter.category) === category;
    }
    if (criteria.startsWith("regex:")) {
      const regex = new RegExp(criteria.substring(6));
      return regex.test(content);
    }
    if (criteria.startsWith("path:")) {
      const pathPattern = criteria.substring(5);
      return this.matchPathPattern(pathPattern, content);
    }
    return content.includes(criteria);
  }
  matchPathPattern(pattern, content) {
    const regex = new RegExp(pattern.replace(/\*/g, ".*"));
    return regex.test(content);
  }
  extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (match) {
      try {
        return JSON.parse(`{${match[1]}}`);
      } catch (e) {
        const frontmatter = {};
        const lines = match[1].split("\n");
        for (const line of lines) {
          const [key, ...values] = line.split(":");
          if (key && values.length) {
            frontmatter[key.trim()] = values.join(":").trim();
          }
        }
        return frontmatter;
      }
    }
    return {};
  }
  formatTargetPath(targetPath, file, frontmatter) {
    return targetPath.replace(/{title}/g, file.basename).replace(/{category}/g, frontmatter.category || "uncategorized").replace(/{date}/g, this.formatDate(frontmatter.date || new Date())).replace(/{type}/g, frontmatter.type || "note");
  }
  formatDate(date) {
    const d = new Date(date);
    return `${d.getFullYear()}/${(d.getMonth() + 1).toString().padStart(2, "0")}/${d.getDate().toString().padStart(2, "0")}`;
  }
};

// src/aiChat.ts
var AIChat = class {
  constructor(app, modelManager) {
    this.messages = [];
    this.messageListeners = [];
    this.app = app;
    this.modelManager = modelManager;
    this.addInitialGreeting();
  }
  addInitialGreeting() {
    this.messages = [{
      role: "assistant",
      content: "Hello! How can I help you today?"
    }];
  }
  getMessages() {
    return this.messages;
  }
  addMessageListener(callback) {
    this.messageListeners.push(callback);
  }
  removeMessageListener(callback) {
    this.messageListeners = this.messageListeners.filter((cb) => cb !== callback);
  }
  notifyListeners() {
    this.messageListeners.forEach((callback) => callback(this.messages));
  }
  async sendMessage(content) {
    try {
      this.messages.push({ role: "user", content });
      this.notifyListeners();
      const response = await this.modelManager.generateText(content);
      this.messages.push({ role: "assistant", content: response });
      this.notifyListeners();
      return response;
    } catch (error) {
      console.error("Error generating response:", error);
      const errorMessage = "Sorry, I encountered an error while processing your request.";
      this.messages.push({ role: "assistant", content: errorMessage });
      this.notifyListeners();
      throw error;
    }
  }
  async appendToNote(content, targetFile) {
    try {
      if (targetFile) {
        const currentContent = await this.app.vault.read(targetFile);
        const newContent = `${currentContent}

${content}`;
        await this.app.vault.modify(targetFile, newContent);
      }
    } catch (error) {
      console.error("Error appending to note:", error);
      throw error;
    }
  }
  clearMessages() {
    this.messages = [];
    this.addInitialGreeting();
    this.notifyListeners();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  modelProvider: ModelProvider.Ollama,
  modelName: "llama2",
  endpoint: "http://localhost:11434",
  apiKey: "",
  embeddingCacheExpiration: 7 * 24 * 60 * 60 * 1e3,
  defaultInboxPath: "inbox",
  pathRules: [],
  modelPreferences: ["mistral", "llama2", "neural-chat"]
};
var AIPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    await this.initializeManagers();
    this.registerView(AI_PLUGIN_VIEW_TYPE, (leaf) => new AIPluginView(leaf, this));
    this.addRibbonIcon("bot", "AI Assistant", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ai-assistant",
      name: "Open AI Assistant",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "suggest-note-location",
      name: "Suggest Note Location",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const suggestedPath = await this.notePathManager.getSuggestedPath(file);
          if (suggestedPath) {
            new PreviewModal2(this.app, {
              original: file.path,
              modified: suggestedPath,
              type: "path"
            }, async (accepted) => {
              if (accepted) {
                await this.notePathManager.moveNote(file, suggestedPath);
              }
            }).open();
          }
        }
      }
    });
    this.addCommand({
      id: "atomize-note",
      name: "Atomize Note",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const atomicNotes = await this.atomizer.atomizeNote(file);
          new AtomicNotesPreviewModal(this.app, atomicNotes, async (accepted) => {
            if (accepted) {
              for (const note of atomicNotes) {
                await this.app.vault.create(`${note.title}.md`, note.content);
              }
            }
          }).open();
        }
      }
    });
    this.addCommand({
      id: "find-similar-notes",
      name: "Find Similar Notes",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const content = await this.app.vault.read(file);
          const results = await this.vaultQuerier.queryVault(content, {
            limit: 5,
            includeContent: true
          });
          new SimilarNotesModal(this.app, results).open();
        }
      }
    });
    this.addCommand({
      id: "extract-concepts",
      name: "Extract Key Concepts",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const content = await this.app.vault.read(file);
          const concepts = await this.nlpManager.performTask({
            type: "keywords",
            options: { minScore: 0.5 }
          }, content);
          new ConceptsModal(this.app, concepts.result).open();
        }
      }
    });
    this.addCommand({
      id: "clean-note",
      name: "Clean Note",
      editorCallback: async (editor) => {
        const content = editor.getValue();
        console.log(content);
        console.log(editor);
        const cleanedContent = await this.textCleaner.cleanText(content);
        editor.setValue(cleanedContent);
      }
    });
    this.addCommand({
      id: "suggest-tags",
      name: "Suggest Tags",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const content = await this.app.vault.read(file);
          const suggestedTags = await this.tagSuggester.suggestTags(file, content);
          new TagSuggestionModal(this.app, suggestedTags, async (accepted) => {
            if (accepted) {
            }
          }).open();
        }
      }
    });
    this.addCommand({
      id: "suggest-title",
      name: "Suggest Title",
      editorCallback: async (editor) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const suggestedTitle = await this.titleSuggester.suggestTitle(file);
          new TitleSuggestionModal(this.app, suggestedTitle, async (accepted) => {
            if (accepted) {
            }
          }).open();
        }
      }
    });
    this.addSettingTab(new AIPluginSettingTab(this.app, this));
  }
  async initializeManagers() {
    this.modelManager = new ModelManager(this.settings.modelProvider, this.settings.modelName, this.settings.endpoint);
    try {
      await this.modelManager.initialize();
    } catch (error) {
      console.error("Failed to initialize model manager:", error);
      new import_obsidian2.Notice("Failed to initialize AI model. Please check your settings and ensure Ollama is running.");
      return;
    }
    this.databaseManager = new DatabaseManager();
    await this.databaseManager.init();
    this.embeddingManager = new EmbeddingManager(this.app.vault, this.modelManager, this.databaseManager, this.settings.embeddingCacheExpiration);
    this.vaultQuerier = new VaultQuerier(this.app.vault, this.embeddingManager, this.databaseManager);
    this.atomizer = new Atomizer(this.app.vault, this.modelManager);
    this.nlpManager = new NLPManager(this.modelManager);
    this.textCleaner = new TextCleaner(this.modelManager);
    this.tagSuggester = new TagSuggester(this.modelManager);
    this.titleSuggester = new TitleSuggester(this.app, this.modelManager, this.vaultQuerier);
    this.notePathManager = new NotePathManager(this.app.vault, this.settings.pathRules);
    this.aiChat = new AIChat(this.app, this.modelManager);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.initializeManagers();
  }
  async activateView() {
    try {
      const { workspace } = this.app;
      let leaf = workspace.getLeavesOfType(AI_PLUGIN_VIEW_TYPE)[0];
      if (!leaf) {
        const rightLeaf = workspace.getRightLeaf(true);
        if (!rightLeaf) {
          console.error("Failed to create right leaf");
          return;
        }
        leaf = rightLeaf;
        await leaf.setViewState({
          type: AI_PLUGIN_VIEW_TYPE,
          active: true
        });
      }
      workspace.revealLeaf(leaf);
    } catch (error) {
      console.error("Error activating view:", error);
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(AI_PLUGIN_VIEW_TYPE);
  }
};
var PreviewModal2 = class extends import_obsidian2.Modal {
  constructor(app, preview, onConfirm) {
    super(app);
    this.preview = preview;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-plugin-preview-modal");
    const content = contentEl.createDiv("ai-plugin-preview-content");
    const originalDiv = content.createDiv("ai-plugin-preview-original");
    originalDiv.createEl("h4", { text: "Current" });
    originalDiv.createEl("pre", { text: this.preview.original });
    const modifiedDiv = content.createDiv("ai-plugin-preview-modified");
    modifiedDiv.createEl("h4", { text: "Suggested" });
    modifiedDiv.createEl("pre", { text: this.preview.modified });
    const actions = contentEl.createDiv("ai-plugin-preview-actions");
    const acceptBtn = actions.createEl("button", {
      cls: "ai-plugin-button",
      text: "Accept"
    });
    acceptBtn.addEventListener("click", () => {
      this.onConfirm(true);
      this.close();
    });
    const rejectBtn = actions.createEl("button", {
      cls: "ai-plugin-button",
      text: "Cancel"
    });
    rejectBtn.addEventListener("click", () => {
      this.onConfirm(false);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AIPluginSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Plugin Settings" });
    new import_obsidian2.Setting(containerEl).setName("Model Provider").setDesc("Select the AI model provider").addDropdown((dropdown) => dropdown.addOption(ModelProvider.Ollama, "Ollama").addOption(ModelProvider.OpenAI, "OpenAI").setValue(this.plugin.settings.modelProvider).onChange(async (value) => {
      this.plugin.settings.modelProvider = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Model Name").setDesc("Enter the model name").addText((text) => text.setPlaceholder("llama2").setValue(this.plugin.settings.modelName).onChange(async (value) => {
      this.plugin.settings.modelName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Endpoint").setDesc("Enter the API endpoint").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.endpoint).onChange(async (value) => {
      this.plugin.settings.endpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("API Key").setDesc("Enter your API key (if required)").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Embedding Cache Expiration").setDesc("Number of days to cache embeddings").addText((text) => text.setPlaceholder("7").setValue(String(this.plugin.settings.embeddingCacheExpiration / (24 * 60 * 60 * 1e3))).onChange(async (value) => {
      const days = parseInt(value) || 7;
      this.plugin.settings.embeddingCacheExpiration = days * 24 * 60 * 60 * 1e3;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Default Inbox Path").setDesc("Path for new notes").addText((text) => text.setPlaceholder("inbox").setValue(this.plugin.settings.defaultInboxPath).onChange(async (value) => {
      this.plugin.settings.defaultInboxPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
